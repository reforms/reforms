ПЛАНЫ, ПРОБЛЕММЫ, ФИШЕЧКИ и РЮШЕЧКИ:

1. Добавить возможность поддержки  транзакций на уровне интерфейсных методов с помощью аннотации Transaction

2. Добавить ПРАВИЛЬНУЮ логику установки NULL значений в объект. На мой взгляд, если значение равно NULL,
   setter метод у объект не должен вызываться или это поведение должно быть настраиваемое.
   Если же он вызывается, сделать проверку примитивов.

[+] 3. Добавить хук на вызов любых методов из интерфейсных DAO в конфигурацию, чтобы можно было реализововывать любые методы, какие пожелаешь.
       [+] Добавлен контракт IMethodInterceptor и методы в конфигурации для добавления/изменения/установки хука на DaoProxy
       [-] IMethodInterceptor сдален как Interceptor а нужно посмотреть в сторону @TargetHook(ClassName) над dao методом - точечный хук

4. Проработать вопрос кеширования аннотируемых методов и их параметров в интерфейсных DAO. Класс DaoProxy

5. Добавить аннотации для bean фильтров: расширить для аннотации TargetFilter скоп @Target(ElementType.FIELD) и
       [-] Добавить поддержку этого в DaoProxy
       [-] Убрать обязательность указания фильтра для int _updateWinner(CurMatchConfirmPayoutRequest request);
           Зачем, если и так понятно, что это именно фильтр!


6. Вносить изменения в документацию и доработать ее основными возможностями Readme.asciidoc

7. Глубоко проработать вопрос с идентификаторами при вставки объектов.
   Как правильно передать управление пользователю на генерацию id?
   Или каким образом сконфигурировать доступ к пользовательскому генератору объекта в SQL выражении?

8. Добавить метод copy во все реализации Expression и сделать кеш String -> Expression для быстрого доступа к Expression по запросу

9. Предоставить API для осуществления тестов DAO слоя:
        Тестирование корректности указания SQL-запросов
        Тестирование корректности меппинга колонок на орм
        Тестирование результатов работы конкретного SQL-запроса

[+] 10. DaoProxy добавить поддержку следующих типов данных при выборке:
       [+] - Iterator по объектам OrmIterator
       [+] - Массив объектов
       [+] - Обработчик объектов OrmHandler
       [+] - Указание любых Set
       [?] - Указание любых List - не только ArrayList - а вообще любых
       [-] - Дать возможность обязательного указания пользовательской ошибки, возможности ее создания и прочее
       [-] - Добавить оборачивание прокси дао в цепочки/фильтры чтобы, скажем можно было логировать начало и конец действия и прочее

11. ВАЖНО! Доработать SQL парсер на поддержку специфических конструкций. см Тест UTestSelectQueryParser

12. Рассмотреть возможность удалять связанную таблицу и ее колонки выборки, если указанные по ней динамические фильтры отсутствуют

[+] 13. Если в SQL-запросе осталась толька одна колонка и возвращаемый тип данных в методе это вовсе не ОРМ,
        то предусматреть и такую возможность: List<String> loadNames(); и List<Integer> loadStates и т.д.
        Частично реализовано в ResultSetSingleReader. Реализовано по типу, а не по кол-ву колонок.
        Если указать тип в аннотации TargetQuery для 'одиночных' значений, все будет ОК

14. Проработка вопроса с хранимыми процедурами:
     API - очень важно.
     [-] Вызов хранимых процедур, без параметров, которая что-то возращает
     [-] Вызов хранимых процедур, с параметрами тип IN, которая что-то возращает/не возращает
     [-] Вызов хранимых процедур, с параметрами тип IN и IN_OUT в одном флакрне, которая что-то возращает/не возращает
     [+] SQL - парсинг.

[+] 15. Проработка вопроса и ИДЕЙ, связанных с батчингом при вставке и обновлении.
        [+] - Добавлена поддержка batch в UPDATE запросе для списков, массивов
        [+] - Добавлена поддержка batch в INSERT запросе для списков, массивов

16. Необходимо повысить информативность ошибок - сейчас они крайне не информативные:
        - 1)   Сделать в объекте поле int, а в БД для этого поля сделать NULL
        - 2)   Сделать в объекте 3 поля, а выбрать 2 -> start_date t#end_date t# - пропусти запятую
        - 3) Проработать вопрос с ошибками. Сейчас все ошибки IllegalStateException, а нужен свой тип и классификатор.


[+] 17. Подготовка к публикациям в англоязычных ресурсах, плюс правки wiki
        [+] https://en.wikipedia.org/wiki/ReformsJDBC
        [-] в англоязычных ресурсах ???

[+] 18. Автоматически определять тип SQL-запроса в DAO proxy
       [+] - SELECT
       [+] - INSERT
       [+] - UPDATE
       [+] - DELETE
       [+] - CALL

19. Добавить поддержку типов в список допустимых при установки значений в PreparedStatement:
       - byte[]
       - InputStream
       - Reader
       [+] - проработать вопрос с EnumParamSetter. Сейчас не допускает null значения но должен. Сделал setObject(x, null);
       [-] - Для выражения m.state IN (:e#match_states) где match_states -  это список енумов нужно ЯВНО указывать директиву e#, а зачем?

[+] 20. Добавлена новыая аннотация TargetDao для указания орм объекта в ней
        [+] Теперь можно писать кратко в методах TargetQuery("SELECT 1"), если указать орм в TargetDao

21. Добавить java-doc для всех классов, помеченных аннотацией @TargetApi

22. Выполнение произвольных скриптов с указанием разделителя:
        [-] @TargetQuery(type = QT_SCRIPT, separator = "GO") executeScript(InputStream or File)
        [-] @TargetQuery(type = QT_SCRIPT, separator = ";" resourcePath = "rc/script.sql") executeScript(InputStream or File)

[+] 23. Автоинкременируемый идентификатор - возращение значения
        [+] Пример см https://github.com/RusZ/TextClassifier/
            statement.executeUpdate(); ResultSet generatedKeys = statement.getGeneratedKeys();
            Теперь, в insert statement можно указывать тип автогенерируемго значения
            Теперь, в insert statement можно boolean как флаг успешной встаки объекта

24. Типы данных:
        [-] Проверить корректность работы с датой и временем.
            Пример установки timestamp в https://www.sitepoint.com/combining-spring-boot-and-jdbi/

25. Идеи
        [-] Можно использовать для схемы+имя_пакета ключ. Пример: schema_name.package_name.tabla_name заменить в
            на schema_name$package_name.tabla_name  и добавить Мерринг ключа
             schema_name$package_name на schema_name.package_name в SchemaManager

[+] 26. Сигнатуры методов List<OrmType> - добывать тип OrmType из констант-пула самого класса!!!
        [+] Добавил немного волшебства и заклинаний: парсер байткода класса -> парсер дескрипторов и сигнатур
            с целью получения одного единственного параметра - типа орм объекта указанного в дженерике.
            public List<String> loadNames(); - Теперь мы знаем, что лист у нас с типом String

28. ДИНАМИЧЕСКИЕ ФИЛЬТРЫ: проработать вопрос с вырезанием из INSERT SQL-запросов
            - 1)  INSERT (name, value) VALUES (:name, ::value) - сейчас упадет

29. Проработка вопроса с СОРТИРОВКОЙ - как управлять????
            - Нужна серверная сортировка, но которая управляется клиентом

30. Когда загружается 1 запись, необходимо предусмотреть возможность бросать исключение, если запись не найдена
        [-] Добавить аннотацию TargetRequired("Невозможно загрузить объект по :id") для 1 записи
        [-] Добавить аннотацию TargetRequired("Невозможно загрузить объект по :filter") для коллекций
        Эта задача связана с пользовательской ошибкой, поддержку которой нужно добавить -> см пункт 10

31. Добавить корректные тесты на префиксные необязательные фильтры, такие как ::t#date или ::e#states
        [-] Проблема в классе QueryPreparer - что-то там хреново с if блоками

32. @TargetFilter - определять по умолчанию для Bean классов
        [-] Сейчас СУБД ругается, так как рассматривает этот фильтр как simple значение а не bean
